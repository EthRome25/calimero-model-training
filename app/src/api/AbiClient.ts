/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import { CalimeroApp, Context } from '@calimero-network/calimero-client';

// Generated types

export interface FileMetadata {
  file_id: string;
  file_type: string;
  access_count: number;
  last_accessed: number;
  tags: string[];
}

export interface ModelFile {
  id: string;
  name: string;
  description: string;
  model_type: string;
  version: string;
  file_size: number;
  file_data: string;
  uploader: string;
  created_at: number;
  is_public: boolean;
}

export interface ScanFile {
  id: string;
  patient_id: string;
  scan_type: string;
  body_part: string;
  file_size: number;
  file_data: string;
  uploader: string;
  created_at: number;
  annotation_count: number;
}

export type AbiEvent =
  | { name: 'ModelUploaded' }
  | { name: 'ScanUploaded' }
  | { name: 'ModelDownloaded' }
  | { name: 'ScanDownloaded' }
  | { name: 'AnnotationAdded' }
  | { name: 'FileDeleted' };

/**
 * Utility class for handling byte conversions in Calimero
 */
export class CalimeroBytes {
  private data: Uint8Array;

  constructor(input: string | number[] | Uint8Array) {
    if (typeof input === 'string') {
      // Hex string
      this.data = new Uint8Array(
        input.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || [],
      );
    } else if (Array.isArray(input)) {
      // Number array
      this.data = new Uint8Array(input);
    } else {
      // Uint8Array
      this.data = input;
    }
  }

  toArray(): number[] {
    return Array.from(this.data);
  }

  toUint8Array(): Uint8Array {
    return this.data;
  }

  static fromHex(hex: string): CalimeroBytes {
    return new CalimeroBytes(hex);
  }

  static fromArray(arr: number[]): CalimeroBytes {
    return new CalimeroBytes(arr);
  }

  static fromUint8Array(bytes: Uint8Array): CalimeroBytes {
    return new CalimeroBytes(bytes);
  }
}

/**
 * Convert CalimeroBytes instances to arrays for WASM compatibility
 */
function convertCalimeroBytesForWasm(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (obj instanceof CalimeroBytes) {
    return obj.toArray();
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => convertCalimeroBytesForWasm(item));
  }

  if (typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertCalimeroBytesForWasm(value);
    }
    return result;
  }

  return obj;
}

/**
 * Convert arrays back to CalimeroBytes instances from WASM responses
 */
function convertWasmResultToCalimeroBytes(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj) && obj.every((item) => typeof item === 'number')) {
    return new CalimeroBytes(obj);
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => convertWasmResultToCalimeroBytes(item));
  }

  if (typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertWasmResultToCalimeroBytes(value);
    }
    return result;
  }

  return obj;
}

export class AbiClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }

  /**
   * init
   */
  public async init(): Promise<void> {
    const response = await this.app.execute(this.context, 'init', {});
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * upload_model
   */
  public async uploadModel(params: {
    name: string;
    description: string;
    model_type: string;
    version: string;
    file_data: string;
    uploader: string;
    is_public: boolean;
  }): Promise<string> {
    console.log('=== API: uploadModel ===');
    console.log('API call parameters:', {
      ...params,
      file_data: `[Base64 string of length ${params.file_data?.length || 0}]`,
    });

    const response = await this.app.execute(
      this.context,
      'upload_model',
      params,
    );

    console.log('API response:', {
      success: response.success,
      result: response.result,
      error: response.error,
    });

    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_model
   */
  public async getModel(params: { model_id: string }): Promise<ModelFile> {
    const response = await this.app.execute(this.context, 'get_model', params);
    if (response.success) {
      return response.result as ModelFile;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_public_models
   */
  public async getPublicModels(): Promise<ModelFile[]> {
    const response = await this.app.execute(
      this.context,
      'get_public_models',
      {},
    );
    if (response.success) {
      return response.result as ModelFile[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * download_model
   */
  public async downloadModel(params: {
    model_id: string;
    downloader: string;
  }): Promise<ModelFile> {
    console.log('=== API: downloadModel ===');
    console.log('API call parameters:', params);

    const response = await this.app.execute(
      this.context,
      'download_model',
      params,
    );

    console.log('API response:', {
      success: response.success,
      result_type: typeof response.result,
      result_keys: response.result ? Object.keys(response.result) : null,
      error: response.error,
    });

    if (response.success) {
      const model = response.result as ModelFile;
      console.log('Downloaded model details:', {
        id: model.id,
        name: model.name,
        file_size: model.file_size,
        file_data_type: typeof model.file_data,
        file_data_length: model.file_data?.length || 0,
      });
      return model;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * upload_scan
   */
  public async uploadScan(params: {
    patient_id: string;
    scan_type: string;
    body_part: string;
    file_data: string;
    uploader: string;
  }): Promise<string> {
    console.log('=== API: uploadScan ===');
    console.log('API call parameters:', {
      ...params,
      file_data: `[Base64 string of length ${params.file_data?.length || 0}]`,
    });

    const response = await this.app.execute(
      this.context,
      'upload_scan',
      params,
    );

    console.log('API response:', {
      success: response.success,
      result: response.result,
      error: response.error,
    });

    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_scan
   */
  public async getScan(params: { scan_id: string }): Promise<ScanFile> {
    const response = await this.app.execute(this.context, 'get_scan', params);
    if (response.success) {
      return response.result as ScanFile;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_scans_by_patient
   */
  public async getScansByPatient(params: {
    patient_id: string;
  }): Promise<ScanFile[]> {
    const response = await this.app.execute(
      this.context,
      'get_scans_by_patient',
      params,
    );
    if (response.success) {
      return response.result as ScanFile[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * download_scan
   */
  public async downloadScan(params: {
    scan_id: string;
    downloader: string;
  }): Promise<ScanFile> {
    console.log('=== API: downloadScan ===');
    console.log('API call parameters:', params);

    const response = await this.app.execute(
      this.context,
      'download_scan',
      params,
    );

    console.log('API response:', {
      success: response.success,
      result_type: typeof response.result,
      result_keys: response.result ? Object.keys(response.result) : null,
      error: response.error,
    });

    if (response.success) {
      const scan = response.result as ScanFile;
      console.log('Downloaded scan details:', {
        id: scan.id,
        patient_id: scan.patient_id,
        scan_type: scan.scan_type,
        file_size: scan.file_size,
        file_data_type: typeof scan.file_data,
        file_data_length: scan.file_data?.length || 0,
      });
      return scan;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * add_annotation
   */
  public async addAnnotation(params: {
    scan_id: string;
    _label: string;
  }): Promise<string> {
    const response = await this.app.execute(
      this.context,
      'add_annotation',
      params,
    );
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_file_metadata
   */
  public async getFileMetadata(params: {
    file_id: string;
  }): Promise<FileMetadata> {
    const response = await this.app.execute(
      this.context,
      'get_file_metadata',
      params,
    );
    if (response.success) {
      return response.result as FileMetadata;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_all_metadata
   */
  public async getAllMetadata(): Promise<FileMetadata[]> {
    const response = await this.app.execute(
      this.context,
      'get_all_metadata',
      {},
    );
    if (response.success) {
      return response.result as FileMetadata[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * delete_file
   */
  public async deleteFile(params: {
    file_id: string;
    file_type: string;
  }): Promise<void> {
    const response = await this.app.execute(
      this.context,
      'delete_file',
      params,
    );
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_stats
   */
  public async getStats(): Promise<string> {
    const response = await this.app.execute(this.context, 'get_stats', {});
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }
}
